<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | 慎独]]></title>
  <link href="http://signifox.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://signifox.github.com/"/>
  <updated>2012-10-31T15:05:14+08:00</updated>
  <id>http://signifox.github.com/</id>
  <author>
    <name><![CDATA[Shawhu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CheckToken]]></title>
    <link href="http://signifox.github.com/blog/2012/10/26/check-token/"/>
    <updated>2012-10-26T00:00:00+08:00</updated>
    <id>http://signifox.github.com/blog/2012/10/26/check-token</id>
    <content type="html"><![CDATA[<h4>一.题目</h4>

<p>检查token字符串是否合法，token可以有多个user:passwd 对，每个user:passwd 对之间至少有一个空格, user和passwd之间不能有任何空格，且都只能为字母或者数字。</p>

<h4>二.我的代码</h4>

<p><div>
  <pre><code class='c'>&lt;/p&gt;

&lt;p&gt;enum STATUS{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ST_INIT,
ST_USER,
ST_SPLIT,
ST_TOKEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;bool check(const char * token){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const char * p = token;

bool hasToken = false; 
bool hasError = false;
STATUS status = ST_INIT;

while((p != NULL) &amp;amp;&amp;amp; (*p != '\0')){
    switch( status){
        case ST_INIT:
        if( isalnum(*p) ){
            status = ST_USER;
        }else if(*p != ' '){
            hasError = true;
        }
        break;
        case ST_USER:
        if(*p == ':'){
            status = ST_SPLIT;
        }else if( !isalnum(*p) ){
            hasError = true;
        }
        break;
        case ST_SPLIT:
        if( isalnum(*p)){
            hasToken = true;
            status = ST_TOKEN;
        }else{
            hasError = true;
        }
        break;
        case ST_TOKEN:
        if(*p == ' '){
            status = ST_INIT;
        }else if( !isalnum(*p) ){
            hasError = true;
        }
        break;
    }
    if( !hasError ){
        p++;
    }else{
        break;
    }
} 
return ( !hasError &amp;amp;&amp;amp; hasToken );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p>

<!-- more -->


<h4>三.同事的代码</h4>

<p><div>
  <pre><code class='c'>bool IsToken(const char* token){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const int N = strlen(token);
int i,nLeft=0,nRight=0,nPair=0,nColon=0;
for(i=0;i&amp;lt;N;i++){
    if(!(isalnum(token[i]) || token[i] == ':' || token[i] == ' ')){
        return false;
    }
    if(token[i] == ':'){
        if(nColon == 1 || nLeft == 0){ //avoid &quot;a::b&quot;,&quot;:b&quot; &quot;a: b&quot;
            return false;
        }
        nColon = 1;
    }else if(token[i] == ' '){
        if(nLeft &amp;gt; 0 &amp;amp;&amp;amp; nColon == 1 &amp;amp;&amp;amp; nRight &amp;gt; 0){ //true
            nPair++;
            nColon = nRight = nLeft = 0;
        }else if(nLeft == 0 &amp;amp;&amp;amp; nColon == 0 &amp;amp;&amp;amp; nRight == 0){ //true
        }else{
            return false;
        }
    }else{ //alpha or number
        if(nColon == 0){
            nLeft++;
        }else{
            nRight++;
        }
    }
}
if(nLeft &amp;gt; 0 &amp;amp;&amp;amp; nColon == 1 &amp;amp;&amp;amp; nRight &amp;gt; 0){ //the last pair
    nPair++;
}
return nPair &amp;gt; 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[const的毛病]]></title>
    <link href="http://signifox.github.com/blog/2012/10/10/const-override/"/>
    <updated>2012-10-10T00:00:00+08:00</updated>
    <id>http://signifox.github.com/blog/2012/10/10/const-override</id>
    <content type="html"><![CDATA[<h3>C++在参数及函数名相同的情况下，const可以构成函数重载。</h3>

<p><div>
  <pre><code class='c'>- void function(){};
- void function() const{};&lt;/p&gt;

&lt;p&gt;-class Object{
public:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void function(){}
inline coid function()const{}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>两者调用优先级如下：</p>

<ul>
<li>类中两种函数都存在时：

<ol>
<li>const对象默认调用const成员函数，非const对象默认调用非const成员函数;</li>
<li>若非const对象想调用const成员函数，则需显式转化，如(const Object&amp;)obj.function();</li>
<li>若const对象想调用非const成员函数，同理const_cast&lt;Object&amp;>(constObj).function()(注意：constObj要加括号);</li>
<li>普通函数（相对于类的成员函数），优先调用非const的函数。</li>
</ol>
</li>
</ul>


<!-- more -->


<ul>
<li>类中只存在一种函数时：

<ol>
<li>非const对象可以调用const成员函数或非const成员函数;</li>
<li>const对象只能调用const成员函数,直接调用非const函数时编译器会报错;</li>
<li>普通函数可以调用const或者非const函数;</li>
<li>const 函数只能调用 const函数，即使某个函数本质上没有修改任何数据，但没有声明为const，也是不能被const函数调用的。</li>
</ol>
</li>
</ul>


<p>说明：
const成员函数不能更改任何非静态成员变量;</p>

<hr />

<h3>const和typedef的 化学反应</h3>

<p>typedef string* pstring;</p>

<p>const pstring cstr;</p>

<p>问题：cstr 是什么类型？</p>

<p>正确的答案应该是：const 指针指向一个 string 类型的对象。</p>

<p>《C++ Primer》：</p>

<blockquote><p>const pstring cstr1;
string* const cstr2;</p>

<p>const string str1;
string const str2;</p></blockquote>

<p>两者类型也相同。</p>
]]></content>
  </entry>
  
</feed>
